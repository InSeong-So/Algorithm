# 시간 복잡도

# 공간 복잡도

# 계산 복잡도

# 증명
- 수학적 귀납법
- 반복문 불변식
- 귀류법

# 문제 유형 파악하기
## 개요 : 문제를 읽기전에 무조건 입출력 제한을 보자

- 입출력 제한을 유심히 보면 어떤 시간복잡도 내에 풀어야 하는지 알 수 있다.
- 예를 들어 입력이 100 이하인 경우 높은 확률로 완전 탐색 문제이다.
  - 시간복잡도 O(N^3) 까지도 감당이 가능하기 때문에 플로이드 워셜과 같이 시간복잡도가 높은 알고리즘도 사용이 가능하다.

### 입력이 100 이하인 경우

- 최대 O(N^3) 이내로 끝내야하는 문제
- 완전 탐색
- 백트래킹

### 입력이 1,000 이하인 경우

- O(N^3) 알고리즘을 사용할 때는 주의
- 반복문의 내부가 단순할 것이므로 시간 안에 수행될 거라 짐작 가능

### 입력이 10,000 이하인 경우

- 최대 O(N^2) 이내로 끝내야하는 문제
- 문제에 따라 O(N^2 log n)까지는 허용
- n\*n 2차원 리스트를 모두 순회해야하는 문제가 많다.

### 입력이 100,000 이하인 경우

- 최대 O(NlogN)으로 끝내야하는 문제
- 힙, 우선순위 큐
- 정렬
- 동적 계획법
- 위상 정렬
- 다익스트라 알고리즘

### 입력이 100,000,000 이하인 경우

- 최대 O(n)으로 끝내야하는 문제
- 동적 계획법
- 그리디

### 그 이상인 경우

- 최대 O(log n)으로 끝내야하는 문제가 많다.
- 거의 안나오는 문제 유형
- 이진탐색


### 정리하자면
O(N^3) 알고리즘 : 크기 2560인 입력을 1초 안에 풀 수 있으며, 2560^3은 대략 160억이다.
O(N^2) 알고리즘 : 크기 40960인 입력을 1초 안에 풀 수 있으며, 40960^2은 대략 16억이다.
O(NlogN) 알고리즘 : 크기가 대략 2천만인 입력까지를 1초 안에 풀 수 있으며, NlogN은 대략 5억이다.
O(N) 알고리즘 : 크기가 대략 1억 6천만인 입력까지를 1초 안에 풀 수 있다.


## 유형 : 자주 출제되는 문제 유형
### 입력값이 작은 문제

위에서 언급했듯 높은 확률로 완전 탐색 혹은 백트래킹이므로 구현력이 중요한 문제일 가능성이 높다.

### 지도가 주어지고 채워진 영역을 찾아야하는 경우

높은 확률로 BFS, DFS이나 `FloodFill`과 같이 정직한 방식으로 나오거나 `전염병`, `치즈` 문제처럼 살짝 변형되서 나오는 경우가 있다.

### 그래프 그림이 있는 경우

이 경우 높은 확률로 세 가지 유형 중 하나이다.

1. 최단 거리 찾기 : 다익스트라, BFS, DFS 등을 사용할 수 있다.
   - `가장 빠른 길`, `최단 거리`와 비슷한 키워드가 나온다면 당연히 최단 거리 찾기 유형이다.
   - `X 비용 내로 갈 수 있는 길을 찾아라`와 같은 키워드도 최단 거리 찾기 유형이다.
2. 최소 신장 트리 : 크루스칼, 프림 알고리즘을 사용할 수 있다.
   - 보통 `가장 저렴한 방법으로 모든 경로 연결해라` 등의 키워드로 출제된다.
   - 경로가 아니라 통신망, 전송 시간, 회로, 배관 등 다양한 용어로 나올 수 있지만 핵심은 모든 경로를 `가장 싸게 연결해라`이다.
   - 그래프는 양방향일수도 단방향일수도 있다.
3. 위상 정렬
   - 순서를 정해야할 때 사용되며 보통 `순서`, `차례` 등의 키워드가 나오면 위상 정렬이다.

### X라는 조건을 만족하는 가장 최대/최소값을 찾아라

높은 확률로 결정 문제이다. 파라메트릭 서치를 이용해서 풀어보자.

### 실시간으로 정렬이 이루어져야 하는 경우

높은 확률로 우선순위 큐 혹은 힙을 사용하는 문제이다.

### Dynamic Programming(DP)

보통 완전 탐색처럼 시간이 오래 걸리면 안되지만 특별한 알고리즘을 사용하는 문제가 아닐 경우 높은 확률로 DP 문제이다.
다른 문제처럼 "딱 봐도 이거네!" 하는 특징이 없어서 유형을 판단하기 힘든 경우 DP로 풀 수 있는지 생각해보자.
종이를 꺼내어 다음과 같이 진행한다.

1. 문제를 따라 먼저 초기값을 적는다.
2. 초기값을 포함해 모든 상태값을 적는다.
3. 현재 상태를 통해 다음 값을 구할 수 있는지 판단한다.
4. 혹은 이전 상태들을 통해 현재 값을 구할 수 있는지 판단한다.

위와 같이 프로세스를 여러 번 진행한 뒤 특정 규칙을 규정하여 함수를 만들어 해결하자.

### 문자열이 주어지는 경우

구현력 문제인 경우가 많다. 문자열을 자르거나, 붙이거나, 탐색하는 문제가 대부분이다.
문자열을 탐색하는 알고리즘이 필요한 경우 KMP 알고리즘을 사용할 수 있지만 보통 파이썬과 같은 스크립트 언어에선 문자열 탐색이 built-in으로 존재하기 때문에 구현에만 집중하자.

### 현재 상황에서 가장 최적인 선택을 해야하는 경우

`항상 최적의 선택`을 해야하는 경우, 혹은 `가장 많은 선택`을 할 수 있는, `가장 작은/큰` 등의 키워드가 들어가면 그리디 문제일 가능성이 높다.
최소 신장 트리도 그리디의 일종이다.