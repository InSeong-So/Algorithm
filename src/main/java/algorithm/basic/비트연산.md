# 알고리즘 해결방법

## 비트 연산자
- 정수형 기본형 데이터 타입의 각 비트를 개별적으로 조작
- 양쪽 피연산자의 대응되는 각 비트별로 boolean 연산

### 비트 연산자의 종류
> `& 연산자` : 비트 AND 연산자로 양쪽 비트가 모두 1일때만 경과가 1이 되고 그렇지않으면 0이 된다.
```
	예) (4 & 5) -> 결과 : 4  ,  (4=100, 5=101)
```

> `| 연산자` : 비트 OR 연산자로 양쪽 비트 중 어느 하나라도 1이면 결과가 1이 되고 모두 0일때만 0이 된다.
```
	예) (4 | 5) -> 결과 : 5 
```

> `^ 연산자 ` : 비트 EXCLUSIVE OR(또는 XOR) 연산자는 양쪽 비트가 서로 다를 때만 1, 같을 때는 0이 됨
```
	예) (4 ^ 5) -> 결과 : 1 
```

> `~ 연산자` : 비트 NOT 연산자는 양쪽 비트 연산자와는 다르게 피연산자를 하나만 갖는 단항 연산자, 모든 비트값을 반대로 만든다 (0->1, 1->0)
```
	예) (~5) -> 결과 : -6
```

## 쉬프트 연산자
- 자바의 기본정수 타입은 반드시 부호(sign)가 있는 정수 값을 가진다. 
- 부호는 제일 왼쪽 한 비트에 표시, 이 비트를 MSB(Most significant Bit : 최상위 비트), 양수 0, 음수 1라고 한다.
- 비트 단위 연산 수행, 기본 정수 타입인 byte, short, char, int, long에만 사용 할 수 있다.

### 쉬프트 연산자의 종류
> `<< 연산자` : 좌측 쉬프트 연산자는 왼편에 있는 피연산자의 비트 값을 연산자 오른편에 지정한 수만큼 왼쪽으로 이동, 오른쪽 남는 비트는 0으로 채움, 부호를 고수

> `>> 연산자` : 우측 쉬프트 연산자는 왼편에 있는 피연산자의 비트 값을 연산자 오른편에 지정한 수만큼 오른쪽으로 이동, 비어있는 왼쪽 비트는 부호와 같은 값으로 채운다, 부호를 고수

> `>>> 연산자` : unsigned 우측 쉬프트 연산자는 왼편의 남는 비트를 부호와는 무관하게 0으로 채운다.

```java
예)
	System.out.println(1 << 2);
	System.out.println(1 >> 2);
	System.out.println(1 >>> 2);
	System.out.println("-----------------");
	System.out.println(-1 << 2);
	System.out.println(-1 >> 2);
	System.out.println(-1 >>> 2);
	System.out.println("-----------------");
	System.out.println(-8 << 2);
	System.out.println(-8 >> 2);
	System.out.println(-8 >>> 2);
	===============================
	4
	0
	0
	-----------------
	-4
	-1
	1073741823
	-----------------
	-32
	-2
	1073741822
```