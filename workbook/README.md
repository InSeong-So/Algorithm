# My Workbook's Page
> 눈과 손에 때려 넣어서 머리로 이해하기 위한 페이지

# 구성
## 구현 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EA%B5%AC%ED%98%84)

## 그래프 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EA%B7%B8%EB%9E%98%ED%94%84)

## 다이나믹 프로그래밍 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EB%8B%A4%EC%9D%B4%EB%82%98%EB%AF%B9%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)

## 브루트 포스 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EB%B8%8C%EB%A3%A8%ED%8A%B8%ED%8F%AC%EC%8A%A4)

## 수학 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EC%88%98%ED%95%99)

## 정렬 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%EC%A0%95%EB%A0%AC)

## 탐색 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%ED%83%90%EC%83%89)

## 탐욕법 [Link](https://github.com/InSeong-So/Algorithm/tree/master/workbook/%ED%83%90%EC%9A%95%EB%B2%95)

<br>

# 노트
- *브루트포스 알고리즘(Bruteforcing)
- *그리디 알고리즘(Greedy)
- *재귀(Recursion)
- *그래프 탐색(Graph Traversal)
- *깊이 우선 탐색(Depth-first Search)
- *너비 우선 탐색(Breadth-first Search)
- *다이나믹 프로그래밍(Dynamic Programming)
- *자료 구조(Data Structures)
- *정렬(Sorting)
- *트리(Tree) : 자료구조
- *이분 탐색(Binary Search)
- *다익스트라(Dijkstra's)
- ~비트마스킹(Bitmask)
- *파싱(Parsing)
- *트리를 사용한 집합과 맵(Set / Map By Trees) : 자료구조
- *연결 리스트(Linked List) : 자료구조
- *스택(Stack) : 자료구조
- *큐(Queue) : 자료구조
- *우선순위 큐(Priority Queue) : 자료구조
- *덱(Deque) : 자료구조
- *분할 정복(Divide And Conquer)
- *에라토스테네스의 체(Sieve Of Eratosthenes)
- *해싱(Hashing)
- *위상 정렬(Topological Sorting)
- *플로이드–와샬(Floyd–warshall)
- *슬라이딩 윈도우(Sliding Window)
- ~두 포인터(Two-pointer)
- ~유클리드 호제법(Euclidean Algorithm)
- *배낭 문제(Knapsack)
- *벨만–포드(Bellman–ford)
- *병렬 이분 탐색(Parallel Binary Search)
- *머지 소트 트리(Merge Sort Tree)
- *외판원 순회 문제(Travelling Salesman Problem)
- 수학(Mathematics)
- 구현(Implementation)
- 그래프 이론(Graph Theory)
- 문자열(String)
- 세그먼트 트리(Segment Tree)
- 정수론(Number Theory)
- 기하학(Geometry)
- 사칙연산(Arithmetic)
- 조합론(Combinatorics) : 순열과 조합에 대해서는 알아야 함
- 시뮬레이션(Simulation)
- 누적 합(Prefix Sum)
- 구성적(Constructive)
- 애드 혹(Ad-hoc)
- 분리 집합(Disjoint Set)
- 백트래킹(Backtracking)
- 많은 조건 분기(Case Work)
- 스위핑(Sweeping)
- 해시를 사용한 집합과 맵(Set / Map By Hashing) : 자료구조
- 트리에서의 다이나믹 프로그래밍(Dynamic Programming On Trees)
- 최대 유량(Maximum Flow)
- 느리게 갱신되는 세그먼트 트리(Segment Tree With Lazy Propagation)
- 소수 판정(Primality Test)
- 비트필드를 이용한 다이나믹 프로그래밍(Dynamic Programming Using Bitfield)
- 게임 이론(Game Theory)
- 분할 정복을 이용한 거듭제곱(Exponentiation By Squaring)
- 오프라인 쿼리(Offline Queries)
- 임의 정밀도 / 큰 수 연산(Arbitrary Precision / Big Integers)
- 최소 스패닝 트리(Minimum Spanning Tree)
- 이분 매칭(Bipartite Matching)
- 최소 공통 조상(Lowest Common Ancestor)
- 강한 연결 요소(Strongly Connected Component)
- 선형대수학(Linear Algebra)
- 볼록 껍질(Convex Hull)
- 확률론(Probability Theory)
- 고속 푸리에 변환(Fast Fourier Transform)
- 포함 배제의 원리(Inclusion And Exclusion)
- 값 / 좌표 압축(Value / Coordinate Compression)
- 런타임 전의 전처리(Precomputation)
- 트라이(Trie)
- 희소 배열(Sparse Table) : 선형대수
- 볼록 껍질을 이용한 최적화(Convex Hull Trick)
- 작은 집합에서 큰 집합으로 합치는 테크닉(Smaller To Larger Technique)
- kmp(Knuth–morris–pratt)
- 최소 비용 최대 유량(Minimum Cost Maximum Flow)
- 접미사 배열과 lcp 배열(Suffix Array And Lcp Array)
- 제곱근 분할법(Square Root Decomposition)
- 매개 변수 탐색(Parametric Search)
- 스프라그–그런디 정리(Sprague–grundy Theorem)
- 중간에서 만나기(Meet In The Middle)
- heavy-light 분할(Heavy-light Decomposition)
- 미적분학(Calculus)
- 가장 긴 증가하는 부분 수열: o(n log n)(Longest Increasing Sequence In O(n Log N))
- 선분 교차 판정(Line Segment Intersection Check)
- 3차원 기하학(Geometry; 3d)
- 오일러 경로 테크닉(Euler Tour Technique)
- 센트로이드 분할(Centroid Decomposition)
- 무작위화(Randomization)
- 2-sat(2-sat)
- 단절점과 단절선(Articulation Points And Bridges)
- 퍼시스턴트 세그먼트 트리(Persistent Segment Tree)
- 비트 집합(Bit Set)
- 가우스 소거법(Gaussian Elimination)
- 삼분 탐색(Ternary Search)
- 오일러 경로(Eulerian Path / Circuit)
- 휴리스틱(Heuristics)
- 최대 유량 최소 컷 정리(Max-flow Min-cut Theorem)
- 선인장(Cactus)
- 물리학(Physics)
- mo's(Mo's)
- 분할 정복을 사용한 최적화(Divide And Conquer Optimization)
- 중국인의 나머지 정리(Chinese Remainder Theorem)
- 평면 그래프(Planar Graph)
- 오일러 지표 (χ=v-e+f)(Euler Characteristic (χ=v-e+f))
- 순열 사이클 분할(Permutation Cycle Decomposition)
- 벌래캠프–매시(Berlekamp–massey)
- 스플레이 트리(Splay Tree)
- 아호-코라식(Aho-corasick)
- 이중 연결 요소(Biconnected Component)
- 다차원 세그먼트 트리(Multidimensional Segment Tree)
- 페르마의 소정리(Fermat's Little Theorem)
- 회전하는 캘리퍼스(Rotating Calipers)
- 0-1 너비 우선 탐색(0-1 Bfs)
- 확장 유클리드 호제법(Extended Euclidean Algorithm)
- 라빈–카프(Rabin–karp)
- 링크/컷 트리(Link/cut Tree)
- 커넥션 프로파일을 이용한 다이나믹 프로그래밍(Dynamic Programming Using Connection Profile)
- 뫼비우스 반전 공식(Möbius Inversion)
- 볼록 다각형 내부의 점 판정(Point In Convex Polygon Check)
- 피타고라스 정리(Pythagoras Theorem)
- 정규 표현식(Regular Expression)
- 덱을 이용한 다이나믹 프로그래밍(Dynamic Programming Using A Deque)
- 오일러 피 함수(Euler Totient Function)
- 매내처(Manacher's)
- 모듈로 곱셈 역원(Modular Multiplicative Inverse)
- 폴라드 로(Pollard Rho)
- 수치해석(Numerical Analysis)
- 인터프리터(Interpreter)
- 다각형의 넓이(Area Of A Polygon)
- aliens 트릭(Aliens Trick)
- 함수 개형을 이용한 최적화(Slope Trick)
- 기댓값의 선형성(Linearity Of Expectation)
- 오프라인 동적 연결성 판정(Offline Dynamic Connectivity)
- 오목 다각형 내부의 점 판정(Point In Non-convex Polygon Check)
- 선형 계획법(Linear Programming)
- 트리 동형 사상(Tree Isomorphism)
- 쌍대 그래프(Dual Graph)
- 번사이드 보조정리(Burnside's Lemma)
- 홀의 결혼 정리(Hall's Theorem)
- 이산 로그(Discrete Logarithm)
- 헝가리안(Hungarian)
- 키타마사(Kitamasa)
- 최소 외접원(Minimum Enclosing Circle)
- 밀러–라빈 소수 판별법(Miller–rabin)
- 보로노이 다이어그램(Voronoi Diagram)
- 매트로이드(Matroid)
- 도미네이터 트리(Dominator Tree)
- 단조 큐를 이용한 최적화(Monotone Queue Optimization)
- 쌍대성(Duality)
- 일반적인 매칭(General Matching)
- 회문 트리(Palindrome Tree)
- 스토어–바그너(Stoer–wagner)
- z(Z)
- 크누스 최적화(Knuth Optimization)
- 뤼카 정리(Lucas Theorem)
- 양방향 탐색(Bidirectional Search)
- 이산 제곱근(Discrete Square Root)
- 통계학(Statistics)
- 유향 최소 신장 트리(Directed Minimum Spanning Tree)
- 4차원 이상의 기하학(Geometry; Hyperdimensional)
- 보이어–무어 다수결 투표(Boyer–moore Majority Vote)
- 히르쉬버그(Hirschberg's)
- 접미사 트리(Suffix Tree)
- 로프(Rope)
- 춤추는 링크(Dancing Links)
- 크누스 x(Knuth's X)
- 델로네 삼각분할(Delaunay Triangulation)
- 레드-블랙 트리(Red-black Tree)
- 탑 트리(Top Tree)
- 베이즈 정리(Bayes Theorem)
- 이산 k제곱근(Discrete K-th Root)
- a*(A*)

//

- 동적 계획법 1
- 그리디 알고리즘
- 분할 정복
- 이분 탐색
- 우선순위 큐
- 동적 계획법 2
- DFS와 BFS
- 최단 경로
- 문자열 알고리즘 1

//

1. 펼쳐놓은 것을 줄여라
2. 문제를 풀고 개념 잡기
3. 개념 이해하고 있는지 확인하기
4. Python으로 풀고 Javascript로 풀기
5. 단원별로 최소 3문제 풀어보고 부족한게 뭔지, 이해할 수 없는게 뭔지 체크해두기
6. 50점 목표로, 차후에 100점까지 간다.